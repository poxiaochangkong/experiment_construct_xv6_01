实验目标
    通过参考xv6的启动机制，理解并实现最小操作系统的引导过程，最终在QEMU中输出"Hello OS"。
xv6的分析
    xv6启动过程：通过kernel.ld文件将代码放入存储空间中，将entry.S放入0x8000000处（qemu平台的约定）。开机先进入0x80000000处的entry.S，entry.S调用start.c，初始化完成后进入main。
系统设计部分
    架构设计部分
        实验一要求实现能开机的最小操作系统，并输出一串字符。实现开机只需实现xv6的entry.S，部分实现start.c与main.c即可。输出字符只需部分实现uart.c即可。
    关键数据结构
        entry.S中的4KB的栈，用于函数调用。
    与xv6对比分析
        由于要求实现最小的能满足要求的操作系统，几乎没有需要存储的数据，且不涉及特权级切换，因此与xv6同名的文件中几乎没有实现各种初始化，代码大幅度简化。
实验过程部分
    实验步骤
        开机部分
            entry.S无需改变，start.c只负责调用main（在未来的实验中会承担初始化的功能），main只实现输出指定的字符串的功能，并进入死循环。
        输出字符串
            部分实现uart.c，实现寄存器的初始化，写入THR，输出字符串等功能
    问题与解决方案
        kernel.ld增加. = _trampoline + 0x1000的代码，这是由于xv6实现的功能非常齐全， _trampoline涉及到中断，在其余的部分完成了改动，我们这里需要主动增加其地址，在未来的要实现中断的实验中也需要实现 _trampoline的变化。
        entry.S无需更改，因为内核数由makefile的编译选项决定，这里我们按照要求设计为1（默认情况）。
测试验证部分
    执行make run 后观察命令行的输出后即可（需要关掉该bash否则会因为死循环大量占用系统资源）。
    预期输出
        Hello，OS！
    输出后进入死循环
